
#include <mega328.h>
#include "sensors.h"
#include "utils.h"
// Standard Input/Output functions
#include <stdio.h>


#define SENSOR1 PINB.0  // 
#define SENSOR2 PINB.1  //
#define SENSOR3 PINB.2  // 
#define SENSOR4 PINB.3  // 
#define SENSOR5 PINB.4 // 
#define SENSOR6 PINB.5  // 
#define SENSOR7 PIND.6  // 
#define SENSOR8 PIND.7  // 
#define SWITCH1 PIND.5	         

// Timebase: 10 kHz (0.1 ms resolution)
#define TICK_HZ          10000UL        // 10,000 per second
#define MIN_GAP_TICKS    50UL           // 5 ms between valid hits (50 * 0.1ms)

// Global time in "ticks" (0.1 ms units at 10 kHz)
volatile unsigned long g_time_ticks = 0;

// Per-lane timing + event flags
volatile unsigned long lane_last_time[8]      = {0};
volatile unsigned long lane_event_time[8]     = {0};
volatile unsigned char lane_event_pending[8]  = {0};

// Debounce / glitch filter: how many *consecutive* low samples seen
static unsigned char low_count[8] = {0};

// Which port each sensor is on: 0 = PINB, 1 = PIND
static const unsigned char sensor_port_index[8] = {
    0,0,0,0,0,0,  // lanes 0..5 on PINB
    1,1           // lanes 6..7 on PIND
};
static const unsigned char sensor_bit_mask[8] = {
    (1<<0), // PB0
    (1<<1), // PB1
    (1<<2), // PB2
    (1<<3), // PB3
    (1<<4), // PB4
    (1<<5), // PB5
    (1<<6), // PD6
    (1<<7)  // PD7
};





// Timer1 overflow interrupt service routine
// Timer1 overflow interrupt service routine
interrupt [TIM1_OVF] void timer1_ovf_isr(void)
{
    unsigned long now;
    unsigned char i;
    unsigned char pinb, pind;
    unsigned char is_low;

    // Reinitialize Timer1 value (your original reload)
    TCNT1H = 0xF9C0 >> 8;
    TCNT1L = 0xF9C0 & 0xff;

    // Global time tick (overflow rate defines resolution)
    g_time_ticks++;
    now = g_time_ticks;

    // Read ports once per ISR
    pinb = PINB;
    pind = PIND;

    // Process all 8 lanes
    for (i = 0; i < 8; i++)
    {
        // Active-low: sensor "on" when pin reads 0
        if (sensor_port_index[i] == 0)
        {
            // lane on PINB
            is_low = ((pinb & sensor_bit_mask[i]) == 0);
        }
        else
        {
            // lane on PIND
            is_low = ((pind & sensor_bit_mask[i]) == 0);
        }

        // Debounce / glitch filter: consecutive low samples
        if (is_low)
        {
            if (low_count[i] < 255)
                low_count[i]++;
        }
        else
        {
            low_count[i] = 0;
        }

        // Enough consecutive lows? (3 samples in a row)
        if (low_count[i] == 3)
        {
            // Min time gap filter (ignore double triggers/glitches)
            if (now - lane_last_time[i] >= MIN_GAP_TICKS)
            {
                lane_last_time[i]      = now;
                lane_event_time[i]     = now;
                lane_event_pending[i]  = 1;
            }
        }
    }
}
